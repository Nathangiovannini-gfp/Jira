package com.almworks.items.entities.dbwrite.impl;

import com.almworks.integers.LongArray;
import com.almworks.items.api.DBAttribute;
import com.almworks.items.api.DP;
import com.almworks.items.dp.DPEquals;
import com.almworks.items.dp.DPNotNull;
import com.almworks.items.entities.api.Entity;
import com.almworks.items.entities.api.EntityKey;
import com.almworks.items.entities.api.EntityValues;
import com.almworks.items.entities.api.util.DataSequence;
import com.almworks.items.entities.api.util.EntityKeyProperties;
import com.almworks.items.entities.dbwrite.ResolutionException;
import com.almworks.items.sync.ItemVersionCreator;
import com.almworks.items.util.SlaveUtils;
import com.almworks.util.LogHelper;
import com.almworks.util.bool.BoolExpr;
import com.almworks.util.collections.ByteArray;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.List;
import java.util.Set;

interface KeyDataKind<K, D> {
  /**
   * Copies corresponding value from source entity to the target item if the value can be converted to DB representation
   * otherwise does nothing (no change is made to item).
   * @param counterpart identifies entity key and item attribute
   * @param resolution facility to resolve entities to items.
   * @param target target item
   * @param source source entity
   * @throws ResolutionException if exception is generated by called method or value surely cannot be copied in any case<br>
   * The exception is not thrown if resolution failed to resolve entity since other resolution implementation may succeed
   */
  void copyValue(KeyCounterpart<K, D> counterpart, WriteResolution resolution, ItemVersionCreator target,
    EntityValues source)
    throws ResolutionException;

  /**
   * Converts entity values to a DB query to find items with corresponding values.<br>
   * Returns not null expression or null if value cannot be converted to DB value
   * @param counterpart identifies entity key and corresponding DB attribute
   * @param resolution facility to resolve entities to DB items
   * @param entity entity values
   * @return search expression if possible
   * @throws ResolutionException resolution error occurred
   */
  @Nullable
  BoolExpr<DP> buildQuery(KeyCounterpart<K, D> counterpart, ItemResolution resolution, EntityValues entity)
    throws ResolutionException;

  DBAttribute<D> checkAttribute(DBAttribute<?> attribute);

  boolean createAttribute(CreateAttributeInfo.Builder builder);

  abstract class RawValue<T> implements KeyDataKind<T, T> {
    private final Class<T> myClass;

    public RawValue(Class<T> aClass) {
      myClass = aClass;
    }

    @Override
    public void copyValue(KeyCounterpart<T, T> counterpart, WriteResolution resolution, ItemVersionCreator target, EntityValues source) {
      target.setValue(counterpart.getAttribute(), source.get(counterpart.getKey()));
    }

    @Override
    public DBAttribute<T> checkAttribute(DBAttribute<?> attribute) {
      return KeyCounterpart.checkAttribute(attribute, DBAttribute.ScalarComposition.SCALAR, myClass);
    }

    @Override
    public boolean createAttribute(CreateAttributeInfo.Builder builder) {
      builder.setProperties(myClass, DBAttribute.ScalarComposition.SCALAR, false);
      return true;
    }
  }

  class Scalar<T> extends RawValue<T> {
    public static final Scalar<String> STRING = create(String.class);
    public static final Scalar<Integer> INT = create(Integer.class);

    public Scalar(Class<T> aClass) {
      super(aClass);
    }

    public static <T> Scalar<T> create(Class<T> aClass) {
      return new Scalar<T>(aClass);
    }

    @Override
    public BoolExpr<DP> buildQuery(KeyCounterpart<T, T> counterpart, ItemResolution resolution, EntityValues entity) {
      EntityKey<T> key = counterpart.getKey();
      T value = entity.get(key);
      DBAttribute<T> attribute = counterpart.getAttribute();
      if (value != null) return DPEquals.create(attribute, value);
      if (entity.getValueKeys().contains(key)) return DPNotNull.create(attribute).negate();
      return null;
    }
  }

  class Sequence implements KeyDataKind<DataSequence, byte[]> {
    public static final Sequence INSTANCE = new Sequence();

    @Override
    public void copyValue(KeyCounterpart<DataSequence, byte[]> counterpart, WriteResolution resolution,
      ItemVersionCreator target, EntityValues source) throws ResolutionException
    {
      DataSequence sequence = source.get(counterpart.getKey());
      if (sequence == null) target.setValue(counterpart.getAttribute(), null);
      else {
        ByteArray array = new ByteArray();
        boolean successful = true;
        for (int i = 0; i < sequence.size(); i++) {
          if (!successful) return;
          Object value = sequence.get(i);
          if (value instanceof Entity) successful = appendItem(array, resolution, (Entity) value);
          else if (value instanceof byte[]) array.add((byte[]) value);
          else if (value instanceof String) array.addUTF8((String) value);
          else if (value instanceof Integer) array.addInt((Integer) value);
          else if (value instanceof Boolean) array.addBoolean(((Boolean) value));
          else LogHelper.error("Unknown data", value);
        }
        target.setValue(counterpart.getAttribute(), array.toNativeArray());
      }
    }

    private boolean appendItem(ByteArray array, WriteResolution resolution, Entity value) throws ResolutionException {
      if (value == null) {
        array.addLong(0);
        return true;
      }
      long item = resolution.resolve(value);
      if (item <= 0) return false;
      array.addLong(item);
      return true;
    }

    @Override
    public BoolExpr<DP> buildQuery(KeyCounterpart<DataSequence, byte[]> counterpart, ItemResolution resolution,
      EntityValues entity) throws ResolutionException
    {
      LogHelper.error("not implemented", counterpart);
      return null;
    }

    @Override
    public DBAttribute<byte[]> checkAttribute(DBAttribute<?> attribute) {
      return KeyCounterpart.checkAttribute(attribute, DBAttribute.ScalarComposition.SCALAR, byte[].class);
    }

    @Override
    public boolean createAttribute(CreateAttributeInfo.Builder builder) {
      builder.setProperties(byte[].class, DBAttribute.ScalarComposition.SCALAR, false);
      return true;
    }
  }

  class RawBytes extends RawValue<byte[]> {
    public static final RawBytes INSTANCE = new RawBytes();

    private RawBytes() {
      super(byte[].class);
    }

    @Override
    public BoolExpr<DP> buildQuery(KeyCounterpart<byte[], byte[]> counterpart, ItemResolution resolution, EntityValues entity) throws ResolutionException {
      LogHelper.error("not implemented", counterpart);
      return null;
    }
  }

  class Link implements KeyDataKind<Entity, Long> {
    public static final Link GENERIC = new Link(EntityKeyProperties.LINK_KIND_GENERIC);
    public static final Link PROPAGATE = new Link(EntityKeyProperties.LINK_KIND_PROPAGATE);
    public static final Link MASTER = new Link(EntityKeyProperties.LINK_KIND_MASTER);

    private final int myKind;

    public Link(int kind) {
      myKind = kind;
    }

    @Override
    public void copyValue(KeyCounterpart<Entity, Long> counterpart, WriteResolution resolution, ItemVersionCreator target,
      EntityValues source) throws ResolutionException {
      Entity value = source.get(counterpart.getKey());
      DBAttribute<Long> attribute = counterpart.getAttribute();
      if (value == null) {
        target.setValue(attribute, (Long)null);
        return;
      }
      long item = resolution.resolve(value);
      if (item > 0) target.setValue(attribute, item);
    }

    @Override
    public BoolExpr<DP> buildQuery(KeyCounterpart<Entity, Long> counterpart, ItemResolution resolution, EntityValues entity)
      throws ResolutionException {
      Entity value = entity.get(counterpart.getKey());
      if (value == null) return null;
      long item = resolution.resolve(value);
      if (item <= 0) return null;
      return DPEquals.create(counterpart.getAttribute(), item);
    }

    @Override
    public boolean createAttribute(CreateAttributeInfo.Builder builder) {
      switch (myKind) {
      case EntityKeyProperties.LINK_KIND_GENERIC:
        builder.setProperties(Long.class, DBAttribute.ScalarComposition.SCALAR, false);
        return true;
      case EntityKeyProperties.LINK_KIND_PROPAGATE:
        builder.setProperties(Long.class, DBAttribute.ScalarComposition.SCALAR, true);
        return true;
      case EntityKeyProperties.LINK_KIND_MASTER:
        builder.setProperties(Long.class, DBAttribute.ScalarComposition.SCALAR, true);
        builder.setValue(SlaveUtils.MASTER_REFERENCE, true);
        return true;
      default:
        LogHelper.error("Unknown link kind", myKind);
        builder.setProperties(Long.class, DBAttribute.ScalarComposition.SCALAR, false);
        return true;
      }
    }

    @Override
    public DBAttribute<Long> checkAttribute(DBAttribute<?> attribute) {
      return KeyCounterpart.checkAttribute(attribute, DBAttribute.ScalarComposition.SCALAR, Long.class);
    }
  }

  class LinkCollection<K extends Collection<Entity>, D extends Collection<Long>> implements KeyDataKind<K, D> {
    private final DBAttribute.ScalarComposition myAttrComposition;
    private final boolean myWriteEmpty;
    
    public static final LinkCollection<Collection<Entity>, Set<Long>> COLLECTION = create(DBAttribute.ScalarComposition.SET, false);
    public static final LinkCollection<Collection<Entity>, Set<Long>> EMPTY_COLLECTION = create(DBAttribute.ScalarComposition.SET, true);
    public static final LinkCollection<List<Entity>, List<Long>> ORDER = create(DBAttribute.ScalarComposition.LIST, false);
    public static final LinkCollection<List<Entity>, List<Long>> EMPTY_ORDER = create(DBAttribute.ScalarComposition.LIST, true);

    private LinkCollection(DBAttribute.ScalarComposition attrComposition, boolean writeEmpty) {
      myAttrComposition = attrComposition;
      myWriteEmpty = writeEmpty;
    }

    private static <K extends Collection<Entity>, D extends Collection<Long>> LinkCollection<K, D> create(DBAttribute.ScalarComposition attrComposition, boolean writeEmpty) {
      return new LinkCollection<K, D>(attrComposition, writeEmpty);
    }

    @Override
    public void copyValue(KeyCounterpart<K, D> counterpart, WriteResolution resolution, ItemVersionCreator target, EntityValues source) throws ResolutionException {
      Collection<? extends Entity> value = source.get(counterpart.getKey());
      DBAttribute<D> attribute = counterpart.getAttribute();
      if (value == null || (value.isEmpty() && !myWriteEmpty)) {
        target.setValue(attribute, null);
        return;
      }
      LongArray items = new LongArray();
      for (Entity entity : value) {
        long item;
        if (entity == null) item = 0;
        else {
          item = resolution.resolve(entity);
          if (item < 0) return;
        }
        items.add(item);
      }
      if (items.isEmpty() && myWriteEmpty) items.add(0);
      switch (myAttrComposition) {
      case SET: target.setSet(attribute, items); break;
      case LIST: target.setList((DBAttribute<List<Long>>) attribute, items); break;
      default:
        LogHelper.error("Wrong composition", myAttrComposition, attribute, counterpart);
      }
    }

    @Override
    public BoolExpr<DP> buildQuery(KeyCounterpart<K, D> counterpart, ItemResolution resolution, EntityValues entity) throws ResolutionException
    {
      LogHelper.error("Should not happen", entity, counterpart);
      return null;
    }

    @Override
    public DBAttribute<D> checkAttribute(DBAttribute<?> attribute) {
      return KeyCounterpart.checkAttribute(attribute, myAttrComposition, Long.class);
    }

    @Override
    public boolean createAttribute(CreateAttributeInfo.Builder builder) {
      switch (myAttrComposition) {
      case SET:
        builder.setProperties(Long.class, DBAttribute.ScalarComposition.SET, false);
        return true;
      case LIST:
        builder.setProperties(Long.class, DBAttribute.ScalarComposition.LIST, false);
        return true;
      default:
        LogHelper.error("Wrong composition", myAttrComposition);
        return false;
      }
    }
  }
}
